{"ast":null,"code":"/* tslint:disable */\n\n/* eslint-disable */\n\n/*!\n * Globalize\n *\n * http://github.com/jquery/globalize\n *\n * Copyright Software Freedom Conservancy, Inc.\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n */\n(function (window, undefined) {\n  if (document.Globalize) {\n    return;\n  }\n\n  var Globalize, // private variables\n  regexHex, regexInfinity, regexParseFloat, regexTrim, // private JavaScript utility functions\n  arrayIndexOf, endsWith, extend, isArray, isFunction, isObject, startsWith, trim, truncate, zeroPad, // private Globalization utility functions\n  appendPreOrPostMatch, expandFormat, formatDate, formatNumber, getTokenRegExp, getEra, getEraYear, parseExact, parseNegativePattern; // Global variable (Globalize) or CommonJS module (globalize)\n\n  Globalize = function (cultureSelector) {\n    return new Globalize.prototype.init(cultureSelector);\n  };\n\n  if (typeof require !== \"undefined\" && typeof exports !== \"undefined\" && typeof module !== \"undefined\") {\n    // Assume CommonJS\n    module.exports = Globalize;\n  } else {\n    // Export as global variable\n    window.Globalize = Globalize;\n  }\n\n  Globalize.cultures = {};\n  Globalize.prototype = {\n    constructor: Globalize,\n    init: function (cultureSelector) {\n      this.cultures = Globalize.cultures;\n      this.cultureSelector = cultureSelector;\n      return this;\n    }\n  };\n  Globalize.prototype.init.prototype = Globalize.prototype; // 1. When defining a culture, all fields are required except the ones stated as optional.\n  // 2. Each culture should have a \".calendars\" object with at least one calendar named \"standard\"\n  //    which serves as the default calendar in use by that culture.\n  // 3. Each culture should have a \".calendar\" object which is the current calendar being used,\n  //    it may be dynamically changed at any time to one of the calendars in \".calendars\".\n\n  Globalize.cultures[\"default\"] = {\n    // A unique name for the culture in the form <language code>-<country/region code>\n    name: \"en\",\n    // the name of the culture in the english language\n    englishName: \"English\",\n    // the name of the culture in its own language\n    nativeName: \"English\",\n    // whether the culture uses right-to-left text\n    isRTL: false,\n    // \"language\" is used for so-called \"specific\" cultures.\n    // For example, the culture \"es-CL\" means \"Spanish, in Chili\".\n    // It represents the Spanish-speaking culture as it is in Chili,\n    // which might have different formatting rules or even translations\n    // than Spanish in Spain. A \"neutral\" culture is one that is not\n    // specific to a region. For example, the culture \"es\" is the generic\n    // Spanish culture, which may be a more generalized version of the language\n    // that may or may not be what a specific culture expects.\n    // For a specific culture like \"es-CL\", the \"language\" field refers to the\n    // neutral, generic culture information for the language it is using.\n    // This is not always a simple matter of the string before the dash.\n    // For example, the \"zh-Hans\" culture is netural (Simplified Chinese).\n    // And the \"zh-SG\" culture is Simplified Chinese in Singapore, whose lanugage\n    // field is \"zh-CHS\", not \"zh\".\n    // This field should be used to navigate from a specific culture to it's\n    // more general, neutral culture. If a culture is already as general as it\n    // can get, the language may refer to itself.\n    language: \"en\",\n    // numberFormat defines general number formatting rules, like the digits in\n    // each grouping, the group separator, and how negative numbers are displayed.\n    numberFormat: {\n      // [negativePattern]\n      // Note, numberFormat.pattern has no \"positivePattern\" unlike percent and currency,\n      // but is still defined as an array for consistency with them.\n      //   negativePattern: one of \"(n)|-n|- n|n-|n -\"\n      pattern: [\"-n\"],\n      // number of decimal places normally shown\n      decimals: 2,\n      // string that separates number groups, as in 1,000,000\n      \",\": \",\",\n      // string that separates a number from the fractional portion, as in 1.99\n      \".\": \".\",\n      // array of numbers indicating the size of each number group.\n      // TODO: more detailed description and example\n      groupSizes: [3],\n      // symbol used for positive numbers\n      \"+\": \"+\",\n      // symbol used for negative numbers\n      \"-\": \"-\",\n      // symbol used for NaN (Not-A-Number)\n      \"NaN\": \"NaN\",\n      // symbol used for Negative Infinity\n      negativeInfinity: \"-Infinity\",\n      // symbol used for Positive Infinity\n      positiveInfinity: \"Infinity\",\n      percent: {\n        // [negativePattern, positivePattern]\n        //   negativePattern: one of \"-n %|-n%|-%n|%-n|%n-|n-%|n%-|-% n|n %-|% n-|% -n|n- %\"\n        //   positivePattern: one of \"n %|n%|%n|% n\"\n        pattern: [\"-n %\", \"n %\"],\n        // number of decimal places normally shown\n        decimals: 2,\n        // array of numbers indicating the size of each number group.\n        // TODO: more detailed description and example\n        groupSizes: [3],\n        // string that separates number groups, as in 1,000,000\n        \",\": \",\",\n        // string that separates a number from the fractional portion, as in 1.99\n        \".\": \".\",\n        // symbol used to represent a percentage\n        symbol: \"%\"\n      },\n      currency: {\n        // [negativePattern, positivePattern]\n        //   negativePattern: one of \"($n)|-$n|$-n|$n-|(n$)|-n$|n-$|n$-|-n $|-$ n|n $-|$ n-|$ -n|n- $|($ n)|(n $)\"\n        //   positivePattern: one of \"$n|n$|$ n|n $\"\n        pattern: [\"($n)\", \"$n\"],\n        // number of decimal places normally shown\n        decimals: 2,\n        // array of numbers indicating the size of each number group.\n        // TODO: more detailed description and example\n        groupSizes: [3],\n        // string that separates number groups, as in 1,000,000\n        \",\": \",\",\n        // string that separates a number from the fractional portion, as in 1.99\n        \".\": \".\",\n        // symbol used to represent currency\n        symbol: \"$\"\n      }\n    },\n    // calendars defines all the possible calendars used by this culture.\n    // There should be at least one defined with name \"standard\", and is the default\n    // calendar used by the culture.\n    // A calendar contains information about how dates are formatted, information about\n    // the calendar's eras, a standard set of the date formats,\n    // translations for day and month names, and if the calendar is not based on the Gregorian\n    // calendar, conversion functions to and from the Gregorian calendar.\n    calendars: {\n      standard: {\n        // name that identifies the type of calendar this is\n        name: \"Gregorian_USEnglish\",\n        // separator of parts of a date (e.g. \"/\" in 11/05/1955)\n        \"/\": \"/\",\n        // separator of parts of a time (e.g. \":\" in 05:44 PM)\n        \":\": \":\",\n        // the first day of the week (0 = Sunday, 1 = Monday, etc)\n        firstDay: 0,\n        days: {\n          // full day names\n          names: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n          // abbreviated day names\n          namesAbbr: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n          // shortest day names\n          namesShort: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]\n        },\n        months: {\n          // full month names (13 months for lunar calendards -- 13th month should be \"\" if not lunar)\n          names: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\", \"\"],\n          // abbreviated month names\n          namesAbbr: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"\"]\n        },\n        // AM and PM designators in one of these forms:\n        // The usual view, and the upper and lower case versions\n        //   [ standard, lowercase, uppercase ]\n        // The culture does not use AM or PM (likely all standard date formats use 24 hour time)\n        //   null\n        AM: [\"AM\", \"am\", \"AM\"],\n        PM: [\"PM\", \"pm\", \"PM\"],\n        eras: [// eras in reverse chronological order.\n        // name: the name of the era in this culture (e.g. A.D., C.E.)\n        // start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.\n        // offset: offset in years from gregorian calendar\n        {\n          \"name\": \"A.D.\",\n          \"start\": null,\n          \"offset\": 0\n        }],\n        // when a two digit year is given, it will never be parsed as a four digit\n        // year greater than this year (in the appropriate era for the culture)\n        // Set it as a full year (e.g. 2029) or use an offset format starting from\n        // the current year: \"+19\" would correspond to 2029 if the current year 2010.\n        twoDigitYearMax: 2029,\n        // set of predefined date and time patterns used by the culture\n        // these represent the format someone in this culture would expect\n        // to see given the portions of the date that are shown.\n        patterns: {\n          // short date pattern\n          d: \"M/d/yyyy\",\n          // long date pattern\n          D: \"dddd, MMMM dd, yyyy\",\n          // short time pattern\n          t: \"h:mm tt\",\n          // long time pattern\n          T: \"h:mm:ss tt\",\n          // long date, short time pattern\n          f: \"dddd, MMMM dd, yyyy h:mm tt\",\n          // long date, long time pattern\n          F: \"dddd, MMMM dd, yyyy h:mm:ss tt\",\n          // month/day pattern\n          M: \"MMMM dd\",\n          // month/year pattern\n          Y: \"yyyy MMMM\",\n          // S is a sortable format that does not vary by culture\n          S: \"yyyy\\u0027-\\u0027MM\\u0027-\\u0027dd\\u0027T\\u0027HH\\u0027:\\u0027mm\\u0027:\\u0027ss\" // optional fields for each calendar:\n\n          /*\n          monthsGenitive:\n          \tSame as months but used when the day preceeds the month.\n          \tOmit if the culture has no genitive distinction in month names.\n          \tFor an explaination of genitive months, see http://blogs.msdn.com/michkap/archive/2004/12/25/332259.aspx\n          convert:\n          \tAllows for the support of non-gregorian based calendars. This convert object is used to\n          \tto convert a date to and from a gregorian calendar date to handle parsing and formatting.\n          \tThe two functions:\n          \t\tfromGregorian( date )\n          \t\t\tGiven the date as a parameter, return an array with parts [ year, month, day ]\n          \t\t\tcorresponding to the non-gregorian based year, month, and day for the calendar.\n          \t\ttoGregorian( year, month, day )\n          \t\t\tGiven the non-gregorian year, month, and day, return a new Date() object\n          \t\t\tset to the corresponding date in the gregorian calendar.\n          */\n\n        }\n      }\n    },\n    // For localized strings\n    messages: {}\n  };\n  Globalize.cultures[\"default\"].calendar = Globalize.cultures[\"default\"].calendars.standard;\n  Globalize.cultures.en = Globalize.cultures[\"default\"];\n  Globalize.cultureSelector = \"en\"; //\n  // private variables\n  //\n\n  regexHex = /^0x[a-f0-9]+$/i;\n  regexInfinity = /^[+\\-]?infinity$/i;\n  regexParseFloat = /^[+\\-]?\\d*\\.?\\d*(e[+\\-]?\\d+)?$/;\n  regexTrim = /^\\s+|\\s+$/g; //\n  // private JavaScript utility functions\n  //\n\n  arrayIndexOf = function (array, item) {\n    if (array.indexOf) {\n      return array.indexOf(item);\n    }\n\n    for (var i = 0, length = array.length; i < length; i++) {\n      if (array[i] === item) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  endsWith = function (value, pattern) {\n    return value.substr(value.length - pattern.length) === pattern;\n  };\n\n  extend = function () {\n    var options,\n        name,\n        src,\n        copy,\n        copyIsArray,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false; // Handle a deep copy situation\n\n    if (typeof target === \"boolean\") {\n      deep = target;\n      target = arguments[1] || {}; // skip the boolean and the target\n\n      i = 2;\n    } // Handle case when target is a string or something (possible in deep copy)\n\n\n    if (typeof target !== \"object\" && !isFunction(target)) {\n      target = {};\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          src = target[name];\n          copy = options[name]; // Prevent never-ending loop\n\n          if (target === copy) {\n            continue;\n          } // Recurse if we're merging plain objects or arrays\n\n\n          if (deep && copy && (isObject(copy) || (copyIsArray = isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && isArray(src) ? src : [];\n            } else {\n              clone = src && isObject(src) ? src : {};\n            } // Never move original objects, clone them\n\n\n            target[name] = extend(deep, clone, copy); // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  isFunction = function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Function]\";\n  };\n\n  isObject = function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n  };\n\n  startsWith = function (value, pattern) {\n    return value.indexOf(pattern) === 0;\n  };\n\n  trim = function (value) {\n    return (value + \"\").replace(regexTrim, \"\");\n  };\n\n  truncate = function (value) {\n    if (isNaN(value)) {\n      return NaN;\n    }\n\n    return Math[value < 0 ? \"ceil\" : \"floor\"](value);\n  };\n\n  zeroPad = function (str, count, left) {\n    var l;\n\n    for (l = str.length; l < count; l += 1) {\n      str = left ? \"0\" + str : str + \"0\";\n    }\n\n    return str;\n  }; //\n  // private Globalization utility functions\n  //\n\n\n  appendPreOrPostMatch = function (preMatch, strings) {\n    // appends pre- and post- token match strings while removing escaped characters.\n    // Returns a single quote count which is used to determine if the token occurs\n    // in a string literal.\n    var quoteCount = 0,\n        escaped = false;\n\n    for (var i = 0, il = preMatch.length; i < il; i++) {\n      var c = preMatch.charAt(i);\n\n      switch (c) {\n        case \"\\'\":\n          if (escaped) {\n            strings.push(\"\\'\");\n          } else {\n            quoteCount++;\n          }\n\n          escaped = false;\n          break;\n\n        case \"\\\\\":\n          if (escaped) {\n            strings.push(\"\\\\\");\n          }\n\n          escaped = !escaped;\n          break;\n\n        default:\n          strings.push(c);\n          escaped = false;\n          break;\n      }\n    }\n\n    return quoteCount;\n  };\n\n  expandFormat = function (cal, format) {\n    // expands unspecified or single character date formats into the full pattern.\n    format = format || \"F\";\n    var pattern,\n        patterns = cal.patterns,\n        len = format.length;\n\n    if (len === 1) {\n      pattern = patterns[format];\n\n      if (!pattern) {\n        throw \"Invalid date format string \\'\" + format + \"\\'.\";\n      }\n\n      format = pattern;\n    } else if (len === 2 && format.charAt(0) === \"%\") {\n      // %X escape format -- intended as a custom format string that is only one character, not a built-in format.\n      format = format.charAt(1);\n    }\n\n    return format;\n  };\n\n  formatDate = function (value, format, culture) {\n    var cal = culture.calendar,\n        convert = cal.convert,\n        ret;\n\n    if (!format || !format.length || format === \"i\") {\n      if (culture && culture.name.length) {\n        if (convert) {\n          // non-gregorian calendar, so we cannot use built-in toLocaleString()\n          ret = formatDate(value, cal.patterns.F, culture);\n        } else {\n          var eraDate = new Date(value.getTime()),\n              era = getEra(value, cal.eras);\n          eraDate.setFullYear(getEraYear(value, cal, era));\n          ret = eraDate.toLocaleString();\n        }\n      } else {\n        ret = value.toString();\n      }\n\n      return ret;\n    }\n\n    var eras = cal.eras,\n        sortable = format === \"s\";\n    format = expandFormat(cal, format); // Start with an empty string\n\n    ret = [];\n    var hour,\n        zeros = [\"0\", \"00\", \"000\"],\n        foundDay,\n        checkedDay,\n        dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,\n        quoteCount = 0,\n        tokenRegExp = getTokenRegExp(),\n        converted; //function padZeros( num, c ) {\n    //\tvar r, s = num + \"\";\n    //\tif ( c > 1 && s.length < c ) {\n    //\t\tr = ( zeros[c - 2] + s);\n    //\t\treturn r.substr( r.length - c, c );\n    //\t}\n    //\telse {\n    //\t\tr = s;\n    //\t}\n    //\treturn r;\n    //}\n\n    function padZeros(num, c) {\n      if (num < 0) {\n        return \"-\" + padZeros(-num, c);\n      }\n\n      var r,\n          s = num + \"\";\n\n      if (c > 1 && s.length < c) {\n        r = zeros[c - 2] + s;\n        return r.substr(r.length - c, c);\n      } else {\n        r = s;\n      }\n\n      return r;\n    }\n\n    function hasDay() {\n      if (foundDay || checkedDay) {\n        return foundDay;\n      }\n\n      foundDay = dayPartRegExp.test(format);\n      checkedDay = true;\n      return foundDay;\n    }\n\n    function getPart(date, part) {\n      if (converted) {\n        return converted[part];\n      }\n\n      switch (part) {\n        case 0:\n          return date.getFullYear();\n\n        case 1:\n          return date.getMonth();\n\n        case 2:\n          return date.getDate();\n\n        default:\n          throw \"Invalid part value \" + part;\n      }\n    }\n\n    if (!sortable && convert) {\n      converted = convert.fromGregorian(value);\n    }\n\n    for (;;) {\n      // Save the current index\n      var index = tokenRegExp.lastIndex,\n          // Look for the next pattern\n      ar = tokenRegExp.exec(format); // Append the text before the pattern (or the end of the string if not found)\n\n      var preMatch = format.slice(index, ar ? ar.index : format.length);\n      quoteCount += appendPreOrPostMatch(preMatch, ret);\n\n      if (!ar) {\n        break;\n      } // do not replace any matches that occur inside a string literal.\n\n\n      if (quoteCount % 2) {\n        ret.push(ar[0]);\n        continue;\n      }\n\n      var current = ar[0],\n          clength = current.length;\n\n      switch (current) {\n        case \"ddd\": //Day of the week, as a three-letter abbreviation\n\n        case \"dddd\":\n          // Day of the week, using the full name\n          var names = clength === 3 ? cal.days.namesAbbr : cal.days.names;\n          ret.push(names[value.getDay()]);\n          break;\n\n        case \"d\": // Day of month, without leading zero for single-digit days\n\n        case \"dd\":\n          // Day of month, with leading zero for single-digit days\n          foundDay = true;\n          ret.push(padZeros(getPart(value, 2), clength));\n          break;\n\n        case \"MMM\": // Month, as a three-letter abbreviation\n\n        case \"MMMM\":\n          // Month, using the full name\n          var part = getPart(value, 1);\n          ret.push(cal.monthsGenitive && hasDay() ? cal.monthsGenitive[clength === 3 ? \"namesAbbr\" : \"names\"][part] : cal.months[clength === 3 ? \"namesAbbr\" : \"names\"][part]);\n          break;\n\n        case \"M\": // Month, as digits, with no leading zero for single-digit months\n\n        case \"MM\":\n          // Month, as digits, with leading zero for single-digit months\n          ret.push(padZeros(getPart(value, 1) + 1, clength));\n          break;\n\n        case \"y\": // Year, as two digits, but with no leading zero for years less than 10\n\n        case \"yy\": // Year, as two digits, with leading zero for years less than 10\n\n        case \"yyyy\":\n          // Year represented by four full digits\n          part = converted ? converted[0] : getEraYear(value, cal, getEra(value, eras), sortable);\n\n          if (clength < 4) {\n            part = part % 100;\n          }\n\n          ret.push(padZeros(part, clength));\n          break;\n\n        case \"h\": // Hours with no leading zero for single-digit hours, using 12-hour clock\n\n        case \"hh\":\n          // Hours with leading zero for single-digit hours, using 12-hour clock\n          hour = value.getHours() % 12;\n          if (hour === 0) hour = 12;\n          ret.push(padZeros(hour, clength));\n          break;\n\n        case \"H\": // Hours with no leading zero for single-digit hours, using 24-hour clock\n\n        case \"HH\":\n          // Hours with leading zero for single-digit hours, using 24-hour clock\n          ret.push(padZeros(value.getHours(), clength));\n          break;\n\n        case \"m\": // Minutes with no leading zero for single-digit minutes\n\n        case \"mm\":\n          // Minutes with leading zero for single-digit minutes\n          ret.push(padZeros(value.getMinutes(), clength));\n          break;\n\n        case \"s\": // Seconds with no leading zero for single-digit seconds\n\n        case \"ss\":\n          // Seconds with leading zero for single-digit seconds\n          ret.push(padZeros(value.getSeconds(), clength));\n          break;\n\n        case \"t\": // One character am/pm indicator (\"a\" or \"p\")\n\n        case \"tt\":\n          // Multicharacter am/pm indicator\n          part = value.getHours() < 12 ? cal.AM ? cal.AM[0] : \" \" : cal.PM ? cal.PM[0] : \" \";\n          ret.push(clength === 1 ? part.charAt(0) : part);\n          break;\n\n        case \"f\": // Deciseconds\n\n        case \"ff\": // Centiseconds\n\n        case \"fff\":\n          // Milliseconds\n          ret.push(padZeros(value.getMilliseconds(), 3).substr(0, clength));\n          break;\n\n        case \"z\": // Time zone offset, no leading zero\n\n        case \"zz\":\n          // Time zone offset with leading zero\n          hour = value.getTimezoneOffset() / 60;\n          ret.push((hour <= 0 ? \"+\" : \"-\") + padZeros(Math.floor(Math.abs(hour)), clength));\n          break;\n\n        case \"zzz\":\n          // Time zone offset with leading zero\n          hour = value.getTimezoneOffset() / 60;\n          ret.push((hour <= 0 ? \"+\" : \"-\") + padZeros(Math.floor(Math.abs(hour)), 2) + // Hard coded \":\" separator, rather than using cal.TimeSeparator\n          // Repeated here for consistency, plus \":\" was already assumed in date parsing.\n          \":\" + padZeros(Math.abs(value.getTimezoneOffset() % 60), 2));\n          break;\n\n        case \"g\":\n        case \"gg\":\n          if (cal.eras) {\n            ret.push(cal.eras[getEra(value, eras)].name);\n          }\n\n          break;\n\n        case \"/\":\n          ret.push(cal[\"/\"]);\n          break;\n\n        default:\n          throw \"Invalid date format pattern \\'\" + current + \"\\'.\";\n      }\n    }\n\n    return ret.join(\"\");\n  }; // formatNumber\n\n\n  (function () {\n    var expandNumber;\n\n    expandNumber = function (number, precision, formatInfo) {\n      var groupSizes = formatInfo.groupSizes,\n          curSize = groupSizes[0],\n          curGroupIndex = 1,\n          factor = Math.pow(10, precision),\n          rounded = Math.round(number * factor) / factor;\n\n      if (!isFinite(rounded)) {\n        rounded = number;\n      }\n\n      number = rounded;\n      var numberString = number + \"\",\n          right = \"\",\n          split = numberString.split(/e/i),\n          exponent = split.length > 1 ? parseInt(split[1], 10) : 0;\n      numberString = split[0];\n      split = numberString.split(\".\");\n      numberString = split[0];\n      right = split.length > 1 ? split[1] : \"\";\n      var l;\n\n      if (exponent > 0) {\n        right = zeroPad(right, exponent, false);\n        numberString += right.slice(0, exponent);\n        right = right.substr(exponent);\n      } else if (exponent < 0) {\n        exponent = -exponent;\n        numberString = zeroPad(numberString, exponent + 1, true);\n        right = numberString.slice(-exponent, numberString.length) + right;\n        numberString = numberString.slice(0, -exponent);\n      }\n\n      if (precision > 0) {\n        right = formatInfo[\".\"] + (right.length > precision ? right.slice(0, precision) : zeroPad(right, precision));\n      } else {\n        right = \"\";\n      }\n\n      var stringIndex = numberString.length - 1,\n          sep = formatInfo[\",\"],\n          ret = \"\";\n\n      while (stringIndex >= 0) {\n        if (curSize === 0 || curSize > stringIndex) {\n          return numberString.slice(0, stringIndex + 1) + (ret.length ? sep + ret + right : right);\n        }\n\n        ret = numberString.slice(stringIndex - curSize + 1, stringIndex + 1) + (ret.length ? sep + ret : \"\");\n        stringIndex -= curSize;\n\n        if (curGroupIndex < groupSizes.length) {\n          curSize = groupSizes[curGroupIndex];\n          curGroupIndex++;\n        }\n      }\n\n      return numberString.slice(0, stringIndex + 1) + sep + ret + right;\n    };\n\n    formatNumber = function (value, format, culture) {\n      if (!isFinite(value)) {\n        if (value === Infinity) {\n          return culture.numberFormat.positiveInfinity;\n        }\n\n        if (value === -Infinity) {\n          return culture.numberFormat.negativeInfinity;\n        }\n\n        return culture.numberFormat.NaN;\n      }\n\n      if (!format || format === \"i\") {\n        return culture.name.length ? value.toLocaleString() : value.toString();\n      }\n\n      format = format || \"D\";\n      var nf = culture.numberFormat,\n          number = Math.abs(value),\n          precision = -1,\n          pattern;\n      if (format.length > 1) precision = parseInt(format.slice(1), 10);\n      var current = format.charAt(0).toUpperCase(),\n          formatInfo;\n\n      switch (current) {\n        case \"D\":\n          pattern = \"n\";\n          number = truncate(number);\n\n          if (precision !== -1) {\n            number = zeroPad(\"\" + number, precision, true);\n          }\n\n          if (value < 0) number = \"-\" + number;\n          break;\n\n        case \"N\":\n          formatInfo = nf;\n\n        /* falls through */\n\n        case \"C\":\n          formatInfo = formatInfo || nf.currency;\n\n        /* falls through */\n\n        case \"P\":\n          formatInfo = formatInfo || nf.percent;\n          pattern = value < 0 ? formatInfo.pattern[0] : formatInfo.pattern[1] || \"n\";\n          if (precision === -1) precision = formatInfo.decimals;\n          number = expandNumber(number * (current === \"P\" ? 100 : 1), precision, formatInfo);\n          break;\n\n        default:\n          throw \"Bad number format specifier: \" + current;\n      }\n\n      var patternParts = /n|\\$|-|%/g,\n          ret = \"\";\n\n      for (;;) {\n        var index = patternParts.lastIndex,\n            ar = patternParts.exec(pattern);\n        ret += pattern.slice(index, ar ? ar.index : pattern.length);\n\n        if (!ar) {\n          break;\n        }\n\n        switch (ar[0]) {\n          case \"n\":\n            ret += number;\n            break;\n\n          case \"$\":\n            ret += nf.currency.symbol;\n            break;\n\n          case \"-\":\n            // don't make 0 negative\n            if (/[1-9]/.test(number)) {\n              ret += nf[\"-\"];\n            }\n\n            break;\n\n          case \"%\":\n            ret += nf.percent.symbol;\n            break;\n        }\n      }\n\n      return ret;\n    };\n  })();\n\n  getTokenRegExp = function () {\n    // regular expression for matching date and time tokens in format strings.\n    return /\\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g;\n  };\n\n  getEra = function (date, eras) {\n    if (!eras) return 0;\n    var start,\n        ticks = date.getTime();\n\n    for (var i = 0, l = eras.length; i < l; i++) {\n      start = eras[i].start;\n\n      if (start === null || ticks >= start) {\n        return i;\n      }\n    }\n\n    return 0;\n  };\n\n  getEraYear = function (date, cal, era, sortable) {\n    var year = date.getFullYear();\n\n    if (!sortable && cal.eras) {\n      // convert normal gregorian year to era-shifted gregorian\n      // year by subtracting the era offset\n      year -= cal.eras[era].offset;\n    }\n\n    return year;\n  }; // parseExact\n\n\n  (function () {\n    var expandYear, getDayIndex, getMonthIndex, getParseRegExp, outOfRange, toUpper, toUpperArray;\n\n    expandYear = function (cal, year) {\n      // expands 2-digit year into 4 digits.\n      if (year < 100) {\n        var now = new Date(),\n            era = getEra(now),\n            curr = getEraYear(now, cal, era),\n            twoDigitYearMax = cal.twoDigitYearMax;\n        twoDigitYearMax = typeof twoDigitYearMax === \"string\" ? new Date().getFullYear() % 100 + parseInt(twoDigitYearMax, 10) : twoDigitYearMax;\n        year += curr - curr % 100;\n\n        if (year > twoDigitYearMax) {\n          year -= 100;\n        }\n      }\n\n      return year;\n    };\n\n    getDayIndex = function (cal, value, abbr) {\n      var ret,\n          days = cal.days,\n          upperDays = cal._upperDays;\n\n      if (!upperDays) {\n        cal._upperDays = upperDays = [toUpperArray(days.names), toUpperArray(days.namesAbbr), toUpperArray(days.namesShort)];\n      }\n\n      value = toUpper(value);\n\n      if (abbr) {\n        ret = arrayIndexOf(upperDays[1], value);\n\n        if (ret === -1) {\n          ret = arrayIndexOf(upperDays[2], value);\n        }\n      } else {\n        ret = arrayIndexOf(upperDays[0], value);\n      }\n\n      return ret;\n    };\n\n    getMonthIndex = function (cal, value, abbr) {\n      var months = cal.months,\n          monthsGen = cal.monthsGenitive || cal.months,\n          upperMonths = cal._upperMonths,\n          upperMonthsGen = cal._upperMonthsGen;\n\n      if (!upperMonths) {\n        cal._upperMonths = upperMonths = [toUpperArray(months.names), toUpperArray(months.namesAbbr)];\n        cal._upperMonthsGen = upperMonthsGen = [toUpperArray(monthsGen.names), toUpperArray(monthsGen.namesAbbr)];\n      }\n\n      value = toUpper(value);\n      var i = arrayIndexOf(abbr ? upperMonths[1] : upperMonths[0], value);\n\n      if (i < 0) {\n        i = arrayIndexOf(abbr ? upperMonthsGen[1] : upperMonthsGen[0], value);\n      }\n\n      return i;\n    };\n\n    getParseRegExp = function (cal, format) {\n      // converts a format string into a regular expression with groups that\n      // can be used to extract date fields from a date string.\n      // check for a cached parse regex.\n      var re = cal._parseRegExp;\n\n      if (!re) {\n        cal._parseRegExp = re = {};\n      } else {\n        var reFormat = re[format];\n\n        if (reFormat) {\n          return reFormat;\n        }\n      } // expand single digit formats, then escape regular expression characters.\n\n\n      var expFormat = expandFormat(cal, format).replace(/([\\^\\$\\.\\*\\+\\?\\|\\[\\]\\(\\)\\{\\}])/g, \"\\\\\\\\$1\"),\n          regexp = [\"^\"],\n          groups = [],\n          index = 0,\n          quoteCount = 0,\n          tokenRegExp = getTokenRegExp(),\n          match; // iterate through each date token found.\n\n      while ((match = tokenRegExp.exec(expFormat)) !== null) {\n        var preMatch = expFormat.slice(index, match.index);\n        index = tokenRegExp.lastIndex; // don't replace any matches that occur inside a string literal.\n\n        quoteCount += appendPreOrPostMatch(preMatch, regexp);\n\n        if (quoteCount % 2) {\n          regexp.push(match[0]);\n          continue;\n        } // add a regex group for the token.\n\n\n        var m = match[0],\n            len = m.length,\n            add;\n\n        switch (m) {\n          case \"dddd\":\n          case \"ddd\":\n          case \"MMMM\":\n          case \"MMM\":\n          case \"gg\":\n          case \"g\":\n            add = \"(\\\\D+)\";\n            break;\n\n          case \"tt\":\n          case \"t\":\n            add = \"(\\\\D*)\";\n            break;\n\n          case \"yyyy\":\n          case \"fff\":\n          case \"ff\":\n          case \"f\":\n            add = \"(\\\\d{\" + len + \"})\";\n            break;\n\n          case \"dd\":\n          case \"d\":\n          case \"MM\":\n          case \"M\":\n          case \"yy\":\n          case \"y\":\n          case \"HH\":\n          case \"H\":\n          case \"hh\":\n          case \"h\":\n          case \"mm\":\n          case \"m\":\n          case \"ss\":\n          case \"s\":\n            add = \"(\\\\d\\\\d?)\";\n            break;\n\n          case \"zzz\":\n            add = \"([+-]?\\\\d\\\\d?:\\\\d{2})\";\n            break;\n\n          case \"zz\":\n          case \"z\":\n            add = \"([+-]?\\\\d\\\\d?)\";\n            break;\n\n          case \"/\":\n            add = \"(\\\\/)\";\n            break;\n\n          default:\n            throw \"Invalid date format pattern \\'\" + m + \"\\'.\";\n        }\n\n        if (add) {\n          regexp.push(add);\n        }\n\n        groups.push(match[0]);\n      }\n\n      appendPreOrPostMatch(expFormat.slice(index), regexp);\n      regexp.push(\"$\"); // allow whitespace to differ when matching formats.\n\n      var regexpStr = regexp.join(\"\").replace(/\\s+/g, \"\\\\s+\"),\n          parseRegExp = {\n        \"regExp\": regexpStr,\n        \"groups\": groups\n      }; // cache the regex for this format.\n\n      return re[format] = parseRegExp;\n    };\n\n    outOfRange = function (value, low, high) {\n      return value < low || value > high;\n    };\n\n    toUpper = function (value) {\n      // \"he-IL\" has non-breaking space in weekday names.\n      return value.split(\"\\u00A0\").join(\" \").toUpperCase();\n    };\n\n    toUpperArray = function (arr) {\n      var results = [];\n\n      for (var i = 0, l = arr.length; i < l; i++) {\n        results[i] = toUpper(arr[i]);\n      }\n\n      return results;\n    };\n\n    parseExact = function (value, format, culture) {\n      // try to parse the date string by matching against the format string\n      // while using the specified culture for date field names.\n      value = trim(value);\n      var cal = culture.calendar,\n          // convert date formats into regular expressions with groupings.\n      // use the regexp to determine the input format and extract the date fields.\n      parseInfo = getParseRegExp(cal, format),\n          match = new RegExp(parseInfo.regExp).exec(value);\n\n      if (match === null) {\n        return null;\n      } // found a date format that matches the input.\n\n\n      var groups = parseInfo.groups,\n          era = null,\n          year = null,\n          month = null,\n          date = null,\n          weekDay = null,\n          hour = 0,\n          hourOffset,\n          min = 0,\n          sec = 0,\n          msec = 0,\n          tzMinOffset = null,\n          pmHour = false; // iterate the format groups to extract and set the date fields.\n\n      for (var j = 0, jl = groups.length; j < jl; j++) {\n        var matchGroup = match[j + 1];\n\n        if (matchGroup) {\n          var current = groups[j],\n              clength = current.length,\n              matchInt = parseInt(matchGroup, 10);\n\n          switch (current) {\n            case \"dd\":\n            case \"d\":\n              // Day of month.\n              date = matchInt; // check that date is generally in valid range, also checking overflow below.\n\n              if (outOfRange(date, 1, 31)) return null;\n              break;\n\n            case \"MMM\":\n            case \"MMMM\":\n              month = getMonthIndex(cal, matchGroup, clength === 3);\n              if (outOfRange(month, 0, 11)) return null;\n              break;\n\n            case \"M\":\n            case \"MM\":\n              // Month.\n              month = matchInt - 1;\n              if (outOfRange(month, 0, 11)) return null;\n              break;\n\n            case \"y\":\n            case \"yy\":\n            case \"yyyy\":\n              year = clength < 4 ? expandYear(cal, matchInt) : matchInt;\n              if (outOfRange(year, 0, 9999)) return null;\n              break;\n\n            case \"h\":\n            case \"hh\":\n              // Hours (12-hour clock).\n              hour = matchInt;\n              if (hour === 12) hour = 0;\n              if (outOfRange(hour, 0, 11)) return null;\n              break;\n\n            case \"H\":\n            case \"HH\":\n              // Hours (24-hour clock).\n              hour = matchInt;\n              if (outOfRange(hour, 0, 23)) return null;\n              break;\n\n            case \"m\":\n            case \"mm\":\n              // Minutes.\n              min = matchInt;\n              if (outOfRange(min, 0, 59)) return null;\n              break;\n\n            case \"s\":\n            case \"ss\":\n              // Seconds.\n              sec = matchInt;\n              if (outOfRange(sec, 0, 59)) return null;\n              break;\n\n            case \"tt\":\n            case \"t\":\n              // AM/PM designator.\n              // see if it is standard, upper, or lower case PM. If not, ensure it is at least one of\n              // the AM tokens. If not, fail the parse for this format.\n              pmHour = cal.PM && (matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2]);\n              if (!pmHour && (!cal.AM || matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2])) return null;\n              break;\n\n            case \"f\": // Deciseconds.\n\n            case \"ff\": // Centiseconds.\n\n            case \"fff\":\n              // Milliseconds.\n              msec = matchInt * Math.pow(10, 3 - clength);\n              if (outOfRange(msec, 0, 999)) return null;\n              break;\n\n            case \"ddd\": // Day of week.\n\n            case \"dddd\":\n              // Day of week.\n              weekDay = getDayIndex(cal, matchGroup, clength === 3);\n              if (outOfRange(weekDay, 0, 6)) return null;\n              break;\n\n            case \"zzz\":\n              // Time zone offset in +/- hours:min.\n              var offsets = matchGroup.split(/:/);\n              if (offsets.length !== 2) return null;\n              hourOffset = parseInt(offsets[0], 10);\n              if (outOfRange(hourOffset, -12, 13)) return null;\n              var minOffset = parseInt(offsets[1], 10);\n              if (outOfRange(minOffset, 0, 59)) return null;\n              tzMinOffset = hourOffset * 60 + (startsWith(matchGroup, \"-\") ? -minOffset : minOffset);\n              break;\n\n            case \"z\":\n            case \"zz\":\n              // Time zone offset in +/- hours.\n              hourOffset = matchInt;\n              if (outOfRange(hourOffset, -12, 13)) return null;\n              tzMinOffset = hourOffset * 60;\n              break;\n\n            case \"g\":\n            case \"gg\":\n              var eraName = matchGroup;\n              if (!eraName || !cal.eras) return null;\n              eraName = trim(eraName.toLowerCase());\n\n              for (var i = 0, l = cal.eras.length; i < l; i++) {\n                if (eraName === cal.eras[i].name.toLowerCase()) {\n                  era = i;\n                  break;\n                }\n              } // could not find an era with that name\n\n\n              if (era === null) return null;\n              break;\n          }\n        }\n      }\n\n      var result = new Date(),\n          defaultYear,\n          convert = cal.convert;\n      defaultYear = convert ? convert.fromGregorian(result)[0] : result.getFullYear();\n\n      if (year === null) {\n        year = defaultYear;\n      } else if (cal.eras) {\n        // year must be shifted to normal gregorian year\n        // but not if year was not specified, its already normal gregorian\n        // per the main if clause above.\n        year += cal.eras[era || 0].offset;\n      } // set default day and month to 1 and January, so if unspecified, these are the defaults\n      // instead of the current day/month.\n\n\n      if (month === null) {\n        month = 0;\n      }\n\n      if (date === null) {\n        date = 1;\n      } // now have year, month, and date, but in the culture's calendar.\n      // convert to gregorian if necessary\n\n\n      if (convert) {\n        result = convert.toGregorian(year, month, date); // conversion failed, must be an invalid match\n\n        if (result === null) return null;\n      } else {\n        // have to set year, month and date together to avoid overflow based on current date.\n        result.setFullYear(year, month, date); // check to see if date overflowed for specified month (only checked 1-31 above).\n\n        if (result.getDate() !== date) return null; // invalid day of week.\n\n        if (weekDay !== null && result.getDay() !== weekDay) {\n          return null;\n        }\n      } // if pm designator token was found make sure the hours fit the 24-hour clock.\n\n\n      if (pmHour && hour < 12) {\n        hour += 12;\n      }\n\n      result.setHours(hour, min, sec, msec);\n\n      if (tzMinOffset !== null) {\n        // adjust timezone to utc before applying local offset.\n        var adjustedMin = result.getMinutes() - (tzMinOffset + result.getTimezoneOffset()); // Safari limits hours and minutes to the range of -127 to 127.  We need to use setHours\n        // to ensure both these fields will not exceed this range.\tadjustedMin will range\n        // somewhere between -1440 and 1500, so we only need to split this into hours.\n\n        result.setHours(result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60);\n      }\n\n      return result;\n    };\n  })();\n\n  parseNegativePattern = function (value, nf, negativePattern) {\n    var neg = nf[\"-\"],\n        pos = nf[\"+\"],\n        ret;\n\n    switch (negativePattern) {\n      case \"n -\":\n        neg = \" \" + neg;\n        pos = \" \" + pos;\n\n      /* falls through */\n\n      case \"n-\":\n        if (endsWith(value, neg)) {\n          ret = [\"-\", value.substr(0, value.length - neg.length)];\n        } else if (endsWith(value, pos)) {\n          ret = [\"+\", value.substr(0, value.length - pos.length)];\n        }\n\n        break;\n\n      case \"- n\":\n        neg += \" \";\n        pos += \" \";\n\n      /* falls through */\n\n      case \"-n\":\n        if (startsWith(value, neg)) {\n          ret = [\"-\", value.substr(neg.length)];\n        } else if (startsWith(value, pos)) {\n          ret = [\"+\", value.substr(pos.length)];\n        }\n\n        break;\n\n      case \"(n)\":\n        if (startsWith(value, \"(\") && endsWith(value, \")\")) {\n          ret = [\"-\", value.substr(1, value.length - 2)];\n        }\n\n        break;\n    }\n\n    return ret || [\"\", value];\n  }; //\n  // public instance functions\n  //\n\n\n  Globalize.prototype.findClosestCulture = function (cultureSelector) {\n    return Globalize.findClosestCulture.call(this, cultureSelector);\n  };\n\n  Globalize.prototype.format = function (value, format, cultureSelector) {\n    return Globalize.format.call(this, value, format, cultureSelector);\n  };\n\n  Globalize.prototype.localize = function (key, cultureSelector) {\n    return Globalize.localize.call(this, key, cultureSelector);\n  };\n\n  Globalize.prototype.parseInt = function (value, radix, cultureSelector) {\n    return Globalize.parseInt.call(this, value, radix, cultureSelector);\n  };\n\n  Globalize.prototype.parseFloat = function (value, radix, cultureSelector) {\n    return Globalize.parseFloat.call(this, value, radix, cultureSelector);\n  };\n\n  Globalize.prototype.culture = function (cultureSelector) {\n    return Globalize.culture.call(this, cultureSelector);\n  }; //\n  // public singleton functions\n  //\n\n\n  Globalize.addCultureInfo = function (cultureName, baseCultureName, info) {\n    var base = {},\n        isNew = false;\n\n    if (typeof cultureName !== \"string\") {\n      // cultureName argument is optional string. If not specified, assume info is first\n      // and only argument. Specified info deep-extends current culture.\n      info = cultureName;\n      cultureName = this.culture().name;\n      base = this.cultures[cultureName];\n    } else if (typeof baseCultureName !== \"string\") {\n      // baseCultureName argument is optional string. If not specified, assume info is second\n      // argument. Specified info deep-extends specified culture.\n      // If specified culture does not exist, create by deep-extending default\n      info = baseCultureName;\n      isNew = this.cultures[cultureName] == null;\n      base = this.cultures[cultureName] || this.cultures[\"default\"];\n    } else {\n      // cultureName and baseCultureName specified. Assume a new culture is being created\n      // by deep-extending an specified base culture\n      isNew = true;\n      base = this.cultures[baseCultureName];\n    }\n\n    this.cultures[cultureName] = extend(true, {}, base, info); // Make the standard calendar the current culture if it's a new culture\n\n    if (isNew) {\n      this.cultures[cultureName].calendar = this.cultures[cultureName].calendars.standard;\n    }\n  };\n\n  Globalize.findClosestCulture = function (name) {\n    var match;\n\n    if (!name) {\n      return this.findClosestCulture(this.cultureSelector) || this.cultures[\"default\"];\n    }\n\n    if (typeof name === \"string\") {\n      name = name.split(\",\");\n    }\n\n    if (isArray(name)) {\n      var lang,\n          cultures = this.cultures,\n          list = name,\n          i,\n          l = list.length,\n          prioritized = [];\n\n      for (i = 0; i < l; i++) {\n        name = trim(list[i]);\n        var pri,\n            parts = name.split(\";\");\n        lang = trim(parts[0]);\n\n        if (parts.length === 1) {\n          pri = 1;\n        } else {\n          name = trim(parts[1]);\n\n          if (name.indexOf(\"q=\") === 0) {\n            name = name.substr(2);\n            pri = parseFloat(name);\n            pri = isNaN(pri) ? 0 : pri;\n          } else {\n            pri = 1;\n          }\n        }\n\n        prioritized.push({\n          lang: lang,\n          pri: pri\n        });\n      }\n\n      prioritized.sort(function (a, b) {\n        if (a.pri < b.pri) {\n          return 1;\n        } else if (a.pri > b.pri) {\n          return -1;\n        }\n\n        return 0;\n      }); // exact match\n\n      for (i = 0; i < l; i++) {\n        lang = prioritized[i].lang;\n        match = cultures[lang];\n\n        if (match) {\n          return match;\n        }\n      } // neutral language match\n\n\n      for (i = 0; i < l; i++) {\n        lang = prioritized[i].lang;\n\n        do {\n          var index = lang.lastIndexOf(\"-\");\n\n          if (index === -1) {\n            break;\n          } // strip off the last part. e.g. en-US => en\n\n\n          lang = lang.substr(0, index);\n          match = cultures[lang];\n\n          if (match) {\n            return match;\n          }\n        } while (1);\n      } // last resort: match first culture using that language\n\n\n      for (i = 0; i < l; i++) {\n        lang = prioritized[i].lang;\n\n        for (var cultureKey in cultures) {\n          var culture = cultures[cultureKey];\n\n          if (culture.language == lang) {\n            return culture;\n          }\n        }\n      }\n    } else if (typeof name === \"object\") {\n      return name;\n    }\n\n    return match || null;\n  };\n\n  Globalize.format = function (value, format, cultureSelector) {\n    var culture = this.findClosestCulture(cultureSelector);\n\n    if (value instanceof Date) {\n      value = formatDate(value, format, culture);\n    } else if (typeof value === \"number\") {\n      value = formatNumber(value, format, culture);\n    }\n\n    return value;\n  };\n\n  Globalize.localize = function (key, cultureSelector) {\n    return this.findClosestCulture(cultureSelector).messages[key] || this.cultures[\"default\"].messages[key];\n  };\n\n  Globalize.parseDate = function (value, formats, culture) {\n    culture = this.findClosestCulture(culture);\n    var date, prop, patterns;\n\n    if (formats) {\n      if (typeof formats === \"string\") {\n        formats = [formats];\n      }\n\n      if (formats.length) {\n        for (var i = 0, l = formats.length; i < l; i++) {\n          var format = formats[i];\n\n          if (format) {\n            date = parseExact(value, format, culture);\n\n            if (date) {\n              break;\n            }\n          }\n        }\n      }\n    } else {\n      patterns = culture.calendar.patterns;\n\n      for (prop in patterns) {\n        date = parseExact(value, patterns[prop], culture);\n\n        if (date) {\n          break;\n        }\n      }\n    }\n\n    return date || null;\n  };\n\n  Globalize.parseInt = function (value, radix, cultureSelector) {\n    return truncate(Globalize.parseFloat(value, radix, cultureSelector));\n  };\n\n  Globalize.parseFloat = function (value, radix, cultureSelector) {\n    // radix argument is optional\n    if (typeof radix !== \"number\") {\n      cultureSelector = radix;\n      radix = 10;\n    }\n\n    var culture = this.findClosestCulture(cultureSelector);\n    var ret = NaN,\n        nf = culture.numberFormat;\n\n    if (value.indexOf(culture.numberFormat.currency.symbol) > -1) {\n      // remove currency symbol\n      value = value.replace(culture.numberFormat.currency.symbol, \"\"); // replace decimal seperator\n\n      value = value.replace(culture.numberFormat.currency[\".\"], culture.numberFormat[\".\"]);\n    } //Remove percentage character from number string before parsing\n\n\n    if (value.indexOf(culture.numberFormat.percent.symbol) > -1) {\n      value = value.replace(culture.numberFormat.percent.symbol, \"\");\n    } // remove spaces: leading, trailing and between - and number. Used for negative currency pt-BR\n\n\n    value = value.replace(/ /g, \"\"); // allow infinity or hexidecimal\n\n    if (regexInfinity.test(value)) {\n      ret = parseFloat(value);\n    } else if (!radix && regexHex.test(value)) {\n      ret = parseInt(value, 16);\n    } else {\n      // determine sign and number\n      var signInfo = parseNegativePattern(value, nf, nf.pattern[0]),\n          sign = signInfo[0],\n          num = signInfo[1]; // #44 - try parsing as \"(n)\"\n\n      if (sign === \"\" && nf.pattern[0] !== \"(n)\") {\n        signInfo = parseNegativePattern(value, nf, \"(n)\");\n        sign = signInfo[0];\n        num = signInfo[1];\n      } // try parsing as \"-n\"\n\n\n      if (sign === \"\" && nf.pattern[0] !== \"-n\") {\n        signInfo = parseNegativePattern(value, nf, \"-n\");\n        sign = signInfo[0];\n        num = signInfo[1];\n      }\n\n      sign = sign || \"+\"; // determine exponent and number\n\n      var exponent,\n          intAndFraction,\n          exponentPos = num.indexOf(\"e\");\n      if (exponentPos < 0) exponentPos = num.indexOf(\"E\");\n\n      if (exponentPos < 0) {\n        intAndFraction = num;\n        exponent = null;\n      } else {\n        intAndFraction = num.substr(0, exponentPos);\n        exponent = num.substr(exponentPos + 1);\n      } // determine decimal position\n\n\n      var integer,\n          fraction,\n          decSep = nf[\".\"],\n          decimalPos = intAndFraction.indexOf(decSep);\n\n      if (decimalPos < 0) {\n        integer = intAndFraction;\n        fraction = null;\n      } else {\n        integer = intAndFraction.substr(0, decimalPos);\n        fraction = intAndFraction.substr(decimalPos + decSep.length);\n      } // handle groups (e.g. 1,000,000)\n\n\n      var groupSep = nf[\",\"];\n      integer = integer.split(groupSep).join(\"\");\n      var altGroupSep = groupSep.replace(/\\u00A0/g, \" \");\n\n      if (groupSep !== altGroupSep) {\n        integer = integer.split(altGroupSep).join(\"\");\n      } // build a natively parsable number string\n\n\n      var p = sign + integer;\n\n      if (fraction !== null) {\n        p += \".\" + fraction;\n      }\n\n      if (exponent !== null) {\n        // exponent itself may have a number patternd\n        var expSignInfo = parseNegativePattern(exponent, nf, \"-n\");\n        p += \"e\" + (expSignInfo[0] || \"+\") + expSignInfo[1];\n      }\n\n      if (regexParseFloat.test(p)) {\n        ret = parseFloat(p);\n      }\n    }\n\n    return ret;\n  };\n\n  Globalize.culture = function (cultureSelector) {\n    // setter\n    if (typeof cultureSelector !== \"undefined\") {\n      this.cultureSelector = cultureSelector;\n    } // getter\n\n\n    return this.findClosestCulture(cultureSelector) || this.cultures[\"default\"];\n  };\n\n  document.Globalize = Globalize;\n})(this);","map":null,"metadata":{},"sourceType":"script"}